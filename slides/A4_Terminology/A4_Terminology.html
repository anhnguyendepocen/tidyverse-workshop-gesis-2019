<!DOCTYPE html>
<html>
  <head>
    <title>Terminology</title>
    <meta charset="utf-8">
    <meta name="author" content="Johannes Breuer Thomas Ebel Stefan Müller" />
    <meta name="date" content="2019-05-15" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/robot-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="..\footer-header.css" type="text/css" />
    <link rel="stylesheet" href="..\mycss.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Terminology
### Johannes Breuer<br />Thomas Ebel<br />Stefan Müller
### 2019-05-15

---

layout: true



&lt;div class="my-footer"&gt;
  &lt;div style="float: left;"&gt;&lt;span&gt;Johannes Breuer &amp; Thomas Ebel &amp; Stefan Müller&lt;/span&gt;&lt;/div&gt;
  &lt;div style="float: right;"&gt;&lt;span&gt;GESIS, Mannheim, Germany, 2019-05-15&lt;/span&gt;&lt;/div&gt;
  &lt;div style="text-align: center;"&gt;&lt;span&gt;Terminology&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

---
# The Power of Terminology

It's maybe common sense to know what other people are talking about.

It's not just words, it's the understanding of them.

As you might know, R contains some many terms and concepts

- object types
- variables types
- function definitions
- etc.

tidyverse adds to this a whole new set of terms that have to be clarified

---
# Pipes and Tibbles

In this session, we will learn about pipes and tibbles.

They are one of the most important terms in the whole uni.. tidyverse.



---
# Nested Functions in Base R

First, let's load some data:


```r
mtcars &lt;- read_csv(readr_example("mtcars.csv"))
```

Say, if we aim to calculate the mean value of the variable `mpg` variable, as smart people we can fire up this command:


```r
mean(read_csv(readr_example("mtcars.csv"))$mpg)
```

```
## [1] 20.09062
```

Pretty, isn't it? Well...

---
# Make it Prettier with Base R

We can use indentions to workaround issues with readablity:


```r
mean(
  read_csv(
    readr_example("mtcars.csv")
    )$mpg
  )
```

```
## [1] 20.09062
```

This works. But it also has some serious flaws:

- Don't you dare to forget closing a bracket
- It's not easy to grasp which operation is the most important one

---
# Disentangling and Overwriting

One easy way is this:


```r
file_string         &lt;- "mtcars.csv"
example_file        &lt;- readr_example(file_string)
example_file_loaded &lt;- read_csv(example_file)
mean(example_file_loaded$mpg)
```

```
## [1] 20.09062
```

Or, to prevent creating too many separate objects:


```r
tmp_object          &lt;- "mtcars.csv"
tmp_object          &lt;- readr_example(tmp_object)
example_file_loaded &lt;- read_csv(tmp_object)
mean(example_file_loaded$mpg)
```

```
## [1] 20.09062
```

Mix to your liking...

---
# Pipes as solution?

Pipes disentangle the whole process in a whole other way and apply each involved function step by step:


```r
"mtcars.csv" %&gt;% 
  readr_example() %&gt;% 
  read_csv() %&gt;% 
  .$mpg %&gt;% 
  mean()
```

```
## [1] 20.09062
```

Most importantly, the central dataset is now on top and the starting point of everything.

---
# Formal Defintion of Pipes: Basic Logic

Usually, in `R` we apply functions as follows:


```r
f(x)
```

In the logic of pipes this function is written as:


```r
x %&gt;% f()
```

Thus, the inner argument/object is placed before the actual function call.

---
# Formal Defintion of Pipes: First Argument

In cases of multiple arguments `x` is always the first argument of the function.

Base R:


```r
f(x, y)
```

Piping:


```r
x %&gt;% f(y)
```

---
# Formal Defintion of Pipes: . as Placeholder

Previously, we learned that `x` always refers to the first argument. We can also make this explicit:


```r
x %&gt;% f(., y)
```

This is useful in case, where `x` does not refer to the first argument:


```r
x %&gt;% f(y, z = .)
```


---
# Notes on Pipes' Styling: Indentions

We can write pipes within one line:


```r
u %&gt;% v %&gt;% w %&gt;% x %&gt;% y %&gt;% z
```

Yet, this destroys the readability. At least for pipes with one than one `%&gt;%` using multiple lines is easier to read:


```r
u %&gt;% 
  v %&gt;% 
  w %&gt;% 
  x %&gt;% 
  y %&gt;% 
  z
```

---
# Notes on Pipes' Styling: Nesting I

As pipes are so convenient you may the tempted to nest operations within pipes and to merge to separate processes, for example:


```r
obj_1 &lt;- 
  u %&gt;% 
  v %&gt;% 
  w

z %&gt;% 
  f(obj1, x) %&gt;% 
  y
```




---
# Notes on Pipes' Styling: Nesting II
To:


```r
z %&gt;% 
  f(
    u %&gt;% 
      v %&gt;% 
      w, 
    x) %&gt;% 
  y
```

While this is nice and cool and stuff, it can get cumbersome ro read

- It may be better to let the processes split up in pipes with more than one `%&gt;%` operator 
- Hadley Wickham himself^{TM} recommends never to use more than ten `%&gt;%` anyway 

---
# Don't Overthink Pipes

Pipes are so nice, you may be tempted to use them all the time.

Some of you may even spend hours to create one single data preparation workflow in one single pipe.

While this is cool, it may not be very sufficient and also misses the whole purpose of applying pipes

- readability
- reproducibility
- and stuff

---
# Alternative Pipe Operators and Related Tools from `magrittr`

- t(ee)-pipes: `%T&gt;%`
- exploding-pipes: `%$%`
- ...
- \{\} brackets

---
&lt;h1&gt; t-Pipes &lt;/h1&gt;


![](mr_t_pipes.png)


&lt;!-- ![](Mr._T_HS_Yearbook.jpg) ![](drainage-pipes-2471293_960_720.jpg) --&gt;
&lt;!-- https://upload.wikimedia.org/wikipedia/commons/8/83/Mr._T_HS_Yearbook.jpg --&gt;
&lt;!-- https://pixabay.com/photos/drainage-pipes-construction-site-2471293/ --&gt;

---
&lt;h1&gt; t-Pipes &lt;/h1&gt;

t-Pipes create some kind of a loophole during a piping process.

They pause the current relationship between previous commands and the current one.

Moreover, they stop the inheritance of the output of the current command.

**t-Pipes can create intermediate results** such as

- plots
- tables

... and continue where we left the main pipe

---
&lt;h1&gt; t-Pipes &lt;/h1&gt;

```r
"mtcars.csv" %&gt;% 
  readr_example() %&gt;% 
  read_csv() %&gt;% 
  .$mpg %T&gt;% 
  plot() %&gt;% # an intermediate plot
  mean()
```

&lt;img src="A4_Terminology_files/figure-html/unnamed-chunk-17-1.png" style="display: block; margin: auto;" /&gt;

```
## [1] 20.09062
```

---
&lt;h1&gt; Exploding Pipes &lt;/h1&gt;

![](exploding_pipes.png) 

&lt;!-- https://pixabay.com/vectors/explosion-detonation-blast-burst-147909/--&gt;
&lt;!-- https://pixabay.com/photos/drainage-pipes-construction-site-2471293/ --&gt;


---
&lt;h1&gt; Exploding Pipes &lt;/h1&gt;


```r
"mtcars.csv" %&gt;% 
  readr_example() %&gt;% 
  read_csv() %&gt;%
  cor(.$disp, .$mpg)
```

This produces an error because piping always expects whole objects, such as data frames, and no single vectors.


```r
"mtcars.csv" %&gt;% 
  readr_example() %&gt;% 
  read_csv() %$% # 'exploding'
  cor(disp, mpg)
```

```
## [1] -0.8475514
```

---
&lt;h1&gt; {} Brackets &lt;/h1&gt;

Another workaround for our problem are curly brackets.

They prevent the first argument to be `.`


```r
"mtcars.csv" %&gt;% 
  readr_example() %&gt;% 
  read_csv() %&gt;% 
  { cor(.$disp, .$mpg) }
```

```
## [1] -0.8475514
```

They are what you may know from other languages being called lamda-functions.

---
# Exercise: Pick One From the Pool of Data
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
