---
title: "Tidy Data"
subtitle: "(according to Hadley Wickham/RStudio)"
author: "Johannes Breuer<br />Thomas Ebel<br />Stefan MÃ¼ller"
date: "2018-05-15"
location: "GESIS, Mannheim, Germany"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["default", "default-fonts", "../footer-header.css", "../mycss.css"]
    nature:
      highlightStyle: "github"
      highlightLines: true
      countIncrementalSlides: false
---
layout: true

```{r setup, include=FALSE}
if (!require(knitr)) install.packages("knitr")
if (!require(rmarkdown)) install.packages("rmarkdown")
if (!require(tidyverse)) install.packages("tidyverse")
library("knitr")
library("rmarkdown")
library("tidyverse")
options(htmltools.dir.version = FALSE)

opts_chunk$set(echo = FALSE, fig.align = "center")
```

<div class="my-footer">
  <div style="float: left;"><span>`r gsub("<br />", " & ", gsub("<br /><br />|<a.+$", "", metadata$author))`</span></div>
  <div style="float: right;"><span>`r metadata$location`, `r metadata$date`</span></div>
  <div style="text-align: center;"><span>`r gsub(".+<br />", " ", metadata$title)`</span></div>
</div>
---
```{r, include=FALSE, warning=FALSE, error=FALSE}
# devtools::install_github("DavZim/colorTable")
library(colorTable)

# define some colors for later
green <- "#a6d96a"
blue  <- "#74add1"
yellow <- "#f4e842"
```
class: center, middle

<h1> What is tidy data?</h1>
<h2> How do we expect data sets to look like?</h2>

---

<h2> The diversity of data </h2>
Data can always be represented in various ways.  
**But** some ways are more common and easy to understand than others.

One reason why data would be non-tidy might be that the focus was on data collection and easy of import instead of on data analysis.  

In any case data analysis often requires to first clean up the data.

Because...

--

- the data set doesn't fit our (or the methods'/tools') expectation about structure.

--

- clean data with standardized structure enable others to replicate/re-run our scripts.

--

- if every data set is organized the same way it's much easier for you to write code.

--

- R-specific: R works with vectors. Highly advantageous to use vectors (i.e. 1 column = 1 variable, 1 row = 1 observation).

---


class: center, middle
<h2>Let's see examples</h2>

Let's experiment: four different ways of displaying the same data.
Which one(s) make(s) sense?

Data is country-level data on population and sampled cases.

---

class: center

<h2>1. example</h2>
```{r, echo=FALSE, warning=FALSE, error=FALSE, results='markup'}
color_table(head(table2, n = 8), body_bg = green, header_bg = blue)
```
Source: tidyr::table2

What's the problem here?

---

```{r}
color_mat <- matrix(c(
  blue, blue, blue, blue,
  green, green, green, yellow,
  green, green, green, green,
  green, green, green, green ),
  ncol = 4, byrow = TRUE)
color_table(head(table2, n = 3), body_bg = color_mat)
```

--

.column-left-half[
Problems
1. Interpretation of cells depends on other cells.
1. Hard to vectorize.
1. 1 column for 2 variables.
]

.column-right-half[
Details
1. The interpretation of 745 depends on the value of "type".
1. R uses vectors internally. Most functions expect a column to represent one cohesive selection of values (e.g. a variable or an observation). Both, "type" and "count" are not.
1. "type" switches the meaning of "count". This is highly unintuitive and not what (most) scientists would expect.
]

--
.bottom[
Solution?

1 column per variable: column name = variable name, cell = value
]
---

class: center, middle

<h2> 2. example</h2>


```{r}
color_table(table3, body_bg = green, header_bg = blue)
```
Source: tidyr::table3


---


```{r}
color_mat <- matrix(c(
  blue, blue, blue,
  green, green, yellow,
  green, green, green,
  green, green, green ),
  ncol = 3, byrow = TRUE)
color_table(head(table3, n = 3), body_bg = color_mat)
```

--

.column-left-half[
Problems
1. Cells contain several values.
1. Cells are strings but represent a number (rate).
]

.column-right-half[
Details
1. It's hard to separate the values in a cell.
1. It's hard to run numeric operations on string variables.
]

--

.bottom[Solution?

1 value per cell! Correct type for cells!
<br>
<br>
<b>Either</b> keep variables "case" and "population" separate and "rate" only contains the numeric result <br><b>or</b> keep only the numeric result in "rate" (discard the information of "case" and "population").
]

---

<h1>A small survey</h1>
Would you actually know how to calculate the rate (with base R) in this case?  
E.g. .highlight["745/19987071"]?  
.smaller[
(Without googling?)
]

--

Would it look something like the following?  

```{r, echo=TRUE}
rate <- c("745/19987071", "2666/20695360")
as.numeric(gsub(rate, pattern = "([0-9]+)/[0-9]+",
                replacement = "\\1")) /
as.numeric(gsub(rate, pattern = "[0-9]+/([0-9]+)",
                replacement = "\\1"))
```

---
<h2> Seriously?</h2>

Would you really want to put yourself and others through this?  
Let's instead provide numeric variables as numbers - not strings!  

.bottom[
By the way - don't worry - you'll learn much nicer ways to handle this situtation during this course either through 
* a new tidyverse verb (separate) or - more generally - 
* string and regular expression operations (package stringr)!
]
---
<h2>Rules for tidy datasets</h2>

There are three interrelated rules which make a dataset tidy:

- Each variable must have its own column.
- Each observation must have its own row.
- Each value must have its own cell.

<img src="../pictures/tidy_data.png" width="100%">
Source: https://r4ds.had.co.nz/tidy-data.html
---
<h2> Short notes on tibbles </h2>

In the tidyverse we put every dataset into a tibble.

A tibble is an improved version of base R's dataframe.  
They can be used instead of dataframes, in most cases **without** breaking existing code.

Improved because...
--

* much nicer output in the console 
   * displaying only as many rows and columns as fit the screen
   * telling dimensions of the dataset
   * telling types of columns
* never changes the data.

More on tibbles in session A4. Or via '?tibble'.

---
<h2>'Gather' a variable</h2>

How to gather/collect a variable that had been spread over 2 columns?  

```{r}
color_mat <- matrix(c(
  blue, blue, blue,
  green, yellow, yellow,
  green, green, green,
  green, green, green ),
  ncol = 3, byrow = TRUE)
color_table(head(table4a, n = 3), body_bg = color_mat)
```

Here, a count variable was spread over 2 columns.  
This is also known as 'wide' format. It's commonly used and there's nothing inherently wrong with it.  
But sometimes 'long' format is required (e.g. in survival analysis).

---

```{r echo=TRUE}
table4a %>%
  head(n = 1) %>%
  gather(`1999`, `2000`, key = "year", value = "cases") %>% #<<
  color_table()
```

The tidyverse verb 'gather' converts the wide format into long format.  

Here, the two columns "1999" and "2000" are gathered into "year" and the counts into "cases".

.bottom[
Before: 
```{r}
color_mat <- matrix(c(
  green, yellow, yellow),
  ncol = 3, byrow = TRUE)
color_table(head(table4a, n = 1), body_bg = color_mat)
```
]

---
<h2>'Spread' a variable</h2>

How to tidy up observations that were spread over two rows?  

```{r}
color_mat <- matrix(c(
  green, green, yellow, yellow,
  green, green, yellow, yellow),
  ncol = 4, byrow = TRUE)
color_table(head(table2, n = 2), body_bg = color_mat, header_bg = blue)
```

Here, one observation was spread over 2 rows.  
This is not ideal either. 

--

By the way, this is **NOT** (an appropriate) long format because the columns are still not cohesive selections of values:  
745 and 19987071 have nothing to do with each other.

---

```{r echo=TRUE}
table2 %>%
  head(n = 2) %>%
  spread(key = type, value = count) %>%  #<<
  color_table()
```
The tidyverse verb 'spread' converts the incohesive selection of values into cohesive vectors/variables.  

Here, the values in "type" become column names of two vectors/variables and the respective values are stored in cells.  

Now this could be used for analyses that require long format!  


.bottom[
Before
```{r echo=FALSE}
color_mat <- matrix(c(
  green, green, yellow, yellow,
  green, green, yellow, yellow),
  ncol = 4, byrow = TRUE)
color_table(head(table2, n = 2), body_bg = color_mat, header_bg = blue)
```
]


---


<h2>Separating intermingled values</h2>
Remember 745/19987071?  

```{r echo=TRUE}

table3 %>%
  head(n = 2) %>%
  separate(rate, into = c("cases", "population")) %>% #<<
  color_table()

```

The tidyverse verb 'separate' allows us to separate intermingled values easily. 

.bottom[
Before:
```{r echo=FALSE}
color_mat <- matrix(c(
  green, green, yellow),
  ncol = 3, byrow = TRUE)

table3 %>%
  head(n = 1) %>%
  color_table(body_bg = color_mat)
```
]

---


But how does separte() know how to split 745/19987071?  

By default, separate will split on any non-alphanumeric character, i.e. everything that's not a digit or a letter.

--

But you can also specific the splitting character yourself with the argument 'sep':  

```{r echo=TRUE}
tibble(mingled = "80/100#1,6_3") %>%
  separate(mingled, into = c("value_1", "value_2"), sep = "#") %>%
  color_table()
```

--


```{r echo=TRUE}
tibble(mingled = "80/100#1,6_3") %>%
  separate(mingled, into = c("value_1", "value_2")) %>%
  color_table()
```

---


<h2>'Uniting' values</h2>

Uniting values that got separated into multiple columns.  

```{r echo=TRUE}
table5 %>%
  select(country, century, year) %>%
  head(n = 1) %>%
  unite(yyyy, century, year, sep = "") %>% #<<
  color_table()
```

The tidyverse verb unite let's us concatenate values that were spread over multiple columns.By default, without specifying 'sep', values are separated by an underscore, '_'.  

.bottom[
Before:
```{r echo=FALSE}
color_mat <- matrix(c(
  green, yellow, yellow),
  ncol = 3, byrow = TRUE)

table5 %>%
  select(country, century, year) %>%
  head(n = 1) %>%
  color_table(body_bg = color_mat)
```
]

---


class: center, middle

<h2> Thanks!</h2>

Slides created via the R package [**xaringan**](https://github.com/yihui/xaringan).

The chakra comes from [remark.js](https://remarkjs.com), [**knitr**](http://yihui.name/knitr), and [R Markdown](https://rmarkdown.rstudio.com).
