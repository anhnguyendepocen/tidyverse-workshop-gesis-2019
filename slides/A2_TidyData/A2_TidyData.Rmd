---
title: "Data Wrangling & Exploration with the Tidyverse in R"
subtitle: "Tidy Data"
author: "Johannes Breuer<br />Thomas Ebel<br />Stefan MÃ¼ller"
date: "2019-05-15"
location: "GESIS, Mannheim, Germany"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["default", "default-fonts", "../footer-header.css", "../mycss.css"]
    nature:
      highlightStyle: "github"
      highlightLines: true
      countIncrementalSlides: false
---
layout: true

```{r setup, include=FALSE}
if (!require(knitr)) install.packages("knitr")
if (!require(rmarkdown)) install.packages("rmarkdown")
if (!require(tidyverse)) install.packages("tidyverse")
library("knitr")
library("rmarkdown")
library("tidyverse")
options(htmltools.dir.version = FALSE)

opts_chunk$set(echo = FALSE, fig.align = "center")

# devtools::install_github("DavZim/colorTable")
library(colorTable)

# define some colors for later
green <- "#a6d96a"
blue  <- "#74add1"
yellow <- "#f4e842"
```

<div class="my-footer">
  <div style="float: left;"><span>`r gsub("<br />", ", ", gsub("<br /><br />|<a.+$", "", metadata$author))`</span></div>
  <div style="float: right;"><span>`r metadata$location`, `r metadata$date`</span></div>
  <div style="text-align: center;"><span>`r gsub(".+<br />", " ", metadata$subtitle)`</span></div>
</div>
---

# The diversity of data

**Data can always be represented in various ways.**

But **some ways are** more common and **easier to understand and use** than others.

> Happy families are all alike; every unhappy family is unhappy in its own way (Leo Tolstoy).

> Tidy datasets are all alike, but every messy dataset is messy in its own way ([Hadley Wickham](https://r4ds.had.co.nz/tidy-data.html))

---

# Data tidying

In most cases, data have to be brought into a specific format before they can be analyzed.

--

Why?

--

- structure of the dataset not in line with the requirements of the methods/tools we use

--

- clean data with standardized structure makes it easier for others to reuse the data

--

- organizing every dataset organized the same way facilitates the reuse of code

--

- R-specific: R works with vectors (hence it makes sense to have 1 column = 1 variable & 1 row = 1 observation)

---

class: center, middle

## Let's have a look at a few examples

In the following, we will compare four different ways of displaying the same data.

Which one(s) make(s) sense?

We will use country-level data on population and cases of a disease.

---

class: center, middle

```{r, echo=FALSE, warning=FALSE, error=FALSE, results='markup'}
color_table(head(table2, n = 8), body_bg = green, header_bg = blue)
```
.large[
What's the problem here?
]

---

```{r}
color_mat <- matrix(c(
  blue, blue, blue, blue,
  green, green, green, yellow,
  green, green, green, green,
  green, green, green, green ),
  ncol = 4, byrow = TRUE)
color_table(head(table2, n = 3), body_bg = color_mat)
```

--

.pull-left[
**Problems**
1. Interpretation of cells depends on other cells

2. Hard to vectorize

3. 1 column for 2 variables
]

.pull-right[
**Details**
1. The interpretation of 745 depends on the value of "type".

2. R uses vectors internally. Most functions expect a column to represent one cohesive selection of values (e.g. a variable or an observation). Both, "type" and "count" are not.

3. "type" switches the meaning of "count". This is highly unintuitive and not what (most) scientists would expect.
]

---

class: center, middle

```{r}
color_table(table3, body_bg = green, header_bg = blue)
```
.large[
What's the problem here?
]

---

```{r}
color_mat <- matrix(c(
  blue, blue, blue,
  green, green, yellow,
  green, green, green,
  green, green, green ),
  ncol = 3, byrow = TRUE)
color_table(head(table3, n = 3), body_bg = color_mat)
```

--

.pull-left[
**Problems**
1. Cells contain several values

1. Cells are strings but represent a number (rate)
]

.pull-right[
**Details**
1. It's hard to separate the values in a cell.

1. It's hard to run numeric operations on string variables.
]

---

<h2>A small survey</h2>

Would you know how to calculate the rate using base R (and regular expressions) in this case?
E.g. .highlight["745/19987071"]?  
.smaller[
(Without googling?)
]

--

Would your code look something like the following?  

```{r, echo=TRUE}
rate <- c("745/19987071", "2666/20695360")
as.numeric(gsub(rate, pattern = "([0-9]+)/[0-9]+",
                replacement = "\\1")) /
as.numeric(gsub(rate, pattern = "[0-9]+/([0-9]+)",
                replacement = "\\1"))
```

---

## Seriously?

Would you really want to put yourself and others through this?  
Let's instead provide numeric variables as numbers - not strings!  

--

Btw., you'll learn much nicer ways to handle this situtation during this course either through 
* a new tidyverse verb (separate) or - more generally - 
* string and regular expression operations (package stringr)!

---

# Rules for tidy datasets

The 3 rules of tidy data:

1. Each **variable** is in a separate **column**.

2. Each **observation** is in a separate **row**.

3. Each **value** is in a separate **cell**.

<img src="pics/tidy_data.png" width="100%">
Source: https://r4ds.had.co.nz/tidy-data.html

NB: In the tidyverse 'tidy data' also means data in long format - where applicable.  

---

## A short notes on tibbles 

Most functions from the tidyverse produce a tibble.

A tibble is an improved version of the base R dataframe.  
They can be used instead of dataframes, in most cases **without** breaking existing code.

Improved because...
--

* much nicer output in the console 
   * displaying only as many rows and columns as fit the screen
   * telling dimensions of the dataset
   * telling types of columns
* never changes the data.

More on tibbles in session A4. Or via '?tibble'.

---

## 'Gather' a variable

How to gather/collect a variable that had been spread over 2 columns?  

```{r}
color_mat <- matrix(c(
  blue, blue, blue,
  green, yellow, yellow,
  green, green, green,
  green, green, green ),
  ncol = 3, byrow = TRUE)
color_table(head(table4a, n = 3), body_bg = color_mat)
```

Here, a count variable was spread over 2 columns.  
This is also known as 'wide' format. It's commonly used and there's nothing inherently wrong with it.  
But sometimes 'long' format is required (e.g. in survival analysis).

---

# 'Gather' a variable

The tidyverse verb 'gather' converts the wide format into long format.  

```{r}
color_mat <- matrix(c(
  green, yellow, yellow),
  ncol = 3, byrow = TRUE)
color_table(head(table4a, n = 1), body_bg = color_mat)
```

```{r echo=TRUE}
table4a %>%
  head(n = 1) %>%
  gather(`1999`, `2000`, key = "year", value = "cases") %>%
  color_table()
```

Here, the two columns "1999" and "2000" are gathered into "year" and the counts into "cases".

---

## 'Spread' a variable

How to tidy up observations that were spread over two rows?  

```{r}
color_mat <- matrix(c(
  green, green, yellow, yellow,
  green, green, yellow, yellow),
  ncol = 4, byrow = TRUE)
color_table(head(table2, n = 2), body_bg = color_mat, header_bg = blue)
```

Here, one observation was spread over 2 rows.  
This is not ideal either. 

--

By the way, this is **NOT** (an appropriate) long format because the columns are still not cohesive selections of values:  
745 and 19987071 have nothing to do with each other.

---

# 'Spread' a variable

The tidyverse verb 'spread' converts the incohesive selection of values into cohesive vectors/variables.

```{r echo=FALSE}
color_mat <- matrix(c(
  green, green, yellow, yellow,
  green, green, yellow, yellow),
  ncol = 4, byrow = TRUE)
color_table(head(table2, n = 2), body_bg = color_mat, header_bg = blue)
```

```{r echo=TRUE}
table2 %>%
  head(n = 2) %>%
  spread(key = type, value = count) %>%  #<<
  color_table()
```
 

Here, the values in "type" become column names of two vectors/variables and the respective values are stored in cells.  

Now this could be used for analyses that require long format!  

---

## Alternatives 

Instead of 'gather' and 'spread' you could also use 'pivot_longer' and 'pivot_wider'. See https://tidyr.tidyverse.org/dev/articles/pivot.html.

---

## Separating intermingled values

The tidyverse verb 'separate' allows us to separate intermingled values.

```{r echo=FALSE}
color_mat <- matrix(c(
  green, green, yellow),
  ncol = 3, byrow = TRUE)

table3 %>%
  head(n = 1) %>%
  color_table(body_bg = color_mat)
```

```{r echo=T}
table3 %>%
  head(n = 2) %>%
  separate(rate, into = c("cases", "population")) %>%
  color_table()
```

---

# Separators

By default `separate()` will split on any non-alphanumeric character, but you can also specify the separating character with the argument 'sep':  

```{r echo=TRUE}
tibble(mingled = "80/100#1,6_3") %>%
  separate(mingled, into = c("value_1", "value_2"), sep = "#") %>%
  color_table()
```

--

```{r echo=TRUE}
tibble(mingled = "80/100#1,6_3") %>%
  separate(mingled, into = c("value_1", "value_2")) %>%
  color_table()
```

---

## 'Uniting' values

The tidyverse verb `unite()` lets us concatenate values that were spread over multiple columns. By default, without specifying 'sep', values are separated by an underscore, '_'. 

```{r echo=FALSE}
color_mat <- matrix(c(
  green, yellow, yellow),
  ncol = 3, byrow = TRUE)

table5 %>%
  select(country, century, year) %>%
  head(n = 1) %>%
  color_table(body_bg = color_mat)
```

```{r echo=TRUE}
table5 %>%
  select(country, century, year) %>%
  head(n = 1) %>%
  unite(yyyy, century, year, sep = "") %>%
  color_table()
```

---

## Your turn! Excercises :) 

```{r}
gapminder_example <- readxl::read_excel(path = "../data/GDPpercapitaconstant2000US.xlsx", sheet = "Data")
```

```{r include=TRUE, echo=TRUE}
# GDP data, for Germany, from 1960 - 2011
# (missings in the first few years)
gapminder_example %>% 
  rename(country = `Income per person (fixed 2000 US$)`) %>%
  filter(country == "Germany") %>%
  select(1:4, last_col())
```


--

Questions
* What's 'wrong' with this dataset?

--
* How do we convert it to long format?

---

## Alternative world: Your turn! Excercises :) 

```{r}
exercise_data <- 
  tibble::tibble(country = rep(c("Germany", "Brazil", "Bulgaria"), 2),
                  type = c(rep("murders", 3), rep("intentional homicide rate", 3)),
                  year = c(rep(2010, 3), 2011, 2011, 2009),
                  cases = c(690, 40974, 147, 0.81, 27, 1.91))
```


```{r echo=TRUE}
exercise_data
```
Source: https://www.nationmaster.com/country-info/stats/Crime/Violent-crime/Intentional-homicide-rate and https://www.nationmaster.com/country-info/stats/Crime/Violent-crime/Murder-rate

--

Question
* What's 'wrong' with this dataset?

---

## Solution 

Problems
   * the meaning of column 'cases' depends on column 'type'.
   * (the dataset is in wide-format).
   
```{r echo=TRUE}
exercise_data %>%
  spread(key = "type", value = "cases")
```


---

class: center, middle

## Thanks!

Slides created via the R package [**xaringan**](https://github.com/yihui/xaringan).

The chakra comes from [remark.js](https://remarkjs.com), [**knitr**](http://yihui.name/knitr), and [R Markdown](https://rmarkdown.rstudio.com).
